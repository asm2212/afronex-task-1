{"version":3,"file":"html-dom-parser.min.js","sources":["../src/client/domparser.ts","../node_modules/domelementtype/lib/esm/index.js","../node_modules/domhandler/lib/esm/node.js","../src/client/constants.ts","../src/client/utilities.ts","../src/client/html-to-dom.ts"],"sourcesContent":[null,"/** Types of elements found in htmlparser2's DOM */\nexport var ElementType;\n(function (ElementType) {\n    /** Type for the root element of a document */\n    ElementType[\"Root\"] = \"root\";\n    /** Type for Text */\n    ElementType[\"Text\"] = \"text\";\n    /** Type for <? ... ?> */\n    ElementType[\"Directive\"] = \"directive\";\n    /** Type for <!-- ... --> */\n    ElementType[\"Comment\"] = \"comment\";\n    /** Type for <script> tags */\n    ElementType[\"Script\"] = \"script\";\n    /** Type for <style> tags */\n    ElementType[\"Style\"] = \"style\";\n    /** Type for Any tag */\n    ElementType[\"Tag\"] = \"tag\";\n    /** Type for <![CDATA[ ... ]]> */\n    ElementType[\"CDATA\"] = \"cdata\";\n    /** Type for <!doctype ...> */\n    ElementType[\"Doctype\"] = \"doctype\";\n})(ElementType || (ElementType = {}));\n/**\n * Tests whether an element is a tag or not.\n *\n * @param elem Element to test\n */\nexport function isTag(elem) {\n    return (elem.type === ElementType.Tag ||\n        elem.type === ElementType.Script ||\n        elem.type === ElementType.Style);\n}\n// Exports for backwards compatibility\n/** Type for the root element of a document */\nexport const Root = ElementType.Root;\n/** Type for Text */\nexport const Text = ElementType.Text;\n/** Type for <? ... ?> */\nexport const Directive = ElementType.Directive;\n/** Type for <!-- ... --> */\nexport const Comment = ElementType.Comment;\n/** Type for <script> tags */\nexport const Script = ElementType.Script;\n/** Type for <style> tags */\nexport const Style = ElementType.Style;\n/** Type for Any tag */\nexport const Tag = ElementType.Tag;\n/** Type for <![CDATA[ ... ]]> */\nexport const CDATA = ElementType.CDATA;\n/** Type for <!doctype ...> */\nexport const Doctype = ElementType.Doctype;\n","import { ElementType, isTag as isTagRaw } from \"domelementtype\";\n/**\n * This object will be used as the prototype for Nodes when creating a\n * DOM-Level-1-compliant structure.\n */\nexport class Node {\n    constructor() {\n        /** Parent of the node */\n        this.parent = null;\n        /** Previous sibling */\n        this.prev = null;\n        /** Next sibling */\n        this.next = null;\n        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n        this.startIndex = null;\n        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n        this.endIndex = null;\n    }\n    // Read-write aliases for properties\n    /**\n     * Same as {@link parent}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get parentNode() {\n        return this.parent;\n    }\n    set parentNode(parent) {\n        this.parent = parent;\n    }\n    /**\n     * Same as {@link prev}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get previousSibling() {\n        return this.prev;\n    }\n    set previousSibling(prev) {\n        this.prev = prev;\n    }\n    /**\n     * Same as {@link next}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get nextSibling() {\n        return this.next;\n    }\n    set nextSibling(next) {\n        this.next = next;\n    }\n    /**\n     * Clone this node, and optionally its children.\n     *\n     * @param recursive Clone child nodes as well.\n     * @returns A clone of the node.\n     */\n    cloneNode(recursive = false) {\n        return cloneNode(this, recursive);\n    }\n}\n/**\n * A node that contains some data.\n */\nexport class DataNode extends Node {\n    /**\n     * @param data The content of the data node\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n    }\n    /**\n     * Same as {@link data}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get nodeValue() {\n        return this.data;\n    }\n    set nodeValue(data) {\n        this.data = data;\n    }\n}\n/**\n * Text within the document.\n */\nexport class Text extends DataNode {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.Text;\n    }\n    get nodeType() {\n        return 3;\n    }\n}\n/**\n * Comments within the document.\n */\nexport class Comment extends DataNode {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.Comment;\n    }\n    get nodeType() {\n        return 8;\n    }\n}\n/**\n * Processing instructions, including doc types.\n */\nexport class ProcessingInstruction extends DataNode {\n    constructor(name, data) {\n        super(data);\n        this.name = name;\n        this.type = ElementType.Directive;\n    }\n    get nodeType() {\n        return 1;\n    }\n}\n/**\n * A `Node` that can have children.\n */\nexport class NodeWithChildren extends Node {\n    /**\n     * @param children Children of the node. Only certain node types can have children.\n     */\n    constructor(children) {\n        super();\n        this.children = children;\n    }\n    // Aliases\n    /** First child of the node. */\n    get firstChild() {\n        var _a;\n        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    /** Last child of the node. */\n    get lastChild() {\n        return this.children.length > 0\n            ? this.children[this.children.length - 1]\n            : null;\n    }\n    /**\n     * Same as {@link children}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get childNodes() {\n        return this.children;\n    }\n    set childNodes(children) {\n        this.children = children;\n    }\n}\nexport class CDATA extends NodeWithChildren {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.CDATA;\n    }\n    get nodeType() {\n        return 4;\n    }\n}\n/**\n * The root node of the document.\n */\nexport class Document extends NodeWithChildren {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.Root;\n    }\n    get nodeType() {\n        return 9;\n    }\n}\n/**\n * An element within the DOM.\n */\nexport class Element extends NodeWithChildren {\n    /**\n     * @param name Name of the tag, eg. `div`, `span`.\n     * @param attribs Object mapping attribute names to attribute values.\n     * @param children Children of the node.\n     */\n    constructor(name, attribs, children = [], type = name === \"script\"\n        ? ElementType.Script\n        : name === \"style\"\n            ? ElementType.Style\n            : ElementType.Tag) {\n        super(children);\n        this.name = name;\n        this.attribs = attribs;\n        this.type = type;\n    }\n    get nodeType() {\n        return 1;\n    }\n    // DOM Level 1 aliases\n    /**\n     * Same as {@link name}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get tagName() {\n        return this.name;\n    }\n    set tagName(name) {\n        this.name = name;\n    }\n    get attributes() {\n        return Object.keys(this.attribs).map((name) => {\n            var _a, _b;\n            return ({\n                name,\n                value: this.attribs[name],\n                namespace: (_a = this[\"x-attribsNamespace\"]) === null || _a === void 0 ? void 0 : _a[name],\n                prefix: (_b = this[\"x-attribsPrefix\"]) === null || _b === void 0 ? void 0 : _b[name],\n            });\n        });\n    }\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node is a `Element`, `false` otherwise.\n */\nexport function isTag(node) {\n    return isTagRaw(node);\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `CDATA`, `false` otherwise.\n */\nexport function isCDATA(node) {\n    return node.type === ElementType.CDATA;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Text`, `false` otherwise.\n */\nexport function isText(node) {\n    return node.type === ElementType.Text;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Comment`, `false` otherwise.\n */\nexport function isComment(node) {\n    return node.type === ElementType.Comment;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nexport function isDirective(node) {\n    return node.type === ElementType.Directive;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nexport function isDocument(node) {\n    return node.type === ElementType.Root;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has children, `false` otherwise.\n */\nexport function hasChildren(node) {\n    return Object.prototype.hasOwnProperty.call(node, \"children\");\n}\n/**\n * Clone a node, and optionally its children.\n *\n * @param recursive Clone child nodes as well.\n * @returns A clone of the node.\n */\nexport function cloneNode(node, recursive = false) {\n    let result;\n    if (isText(node)) {\n        result = new Text(node.data);\n    }\n    else if (isComment(node)) {\n        result = new Comment(node.data);\n    }\n    else if (isTag(node)) {\n        const children = recursive ? cloneChildren(node.children) : [];\n        const clone = new Element(node.name, { ...node.attribs }, children);\n        children.forEach((child) => (child.parent = clone));\n        if (node.namespace != null) {\n            clone.namespace = node.namespace;\n        }\n        if (node[\"x-attribsNamespace\"]) {\n            clone[\"x-attribsNamespace\"] = { ...node[\"x-attribsNamespace\"] };\n        }\n        if (node[\"x-attribsPrefix\"]) {\n            clone[\"x-attribsPrefix\"] = { ...node[\"x-attribsPrefix\"] };\n        }\n        result = clone;\n    }\n    else if (isCDATA(node)) {\n        const children = recursive ? cloneChildren(node.children) : [];\n        const clone = new CDATA(children);\n        children.forEach((child) => (child.parent = clone));\n        result = clone;\n    }\n    else if (isDocument(node)) {\n        const children = recursive ? cloneChildren(node.children) : [];\n        const clone = new Document(children);\n        children.forEach((child) => (child.parent = clone));\n        if (node[\"x-mode\"]) {\n            clone[\"x-mode\"] = node[\"x-mode\"];\n        }\n        result = clone;\n    }\n    else if (isDirective(node)) {\n        const instruction = new ProcessingInstruction(node.name, node.data);\n        if (node[\"x-name\"] != null) {\n            instruction[\"x-name\"] = node[\"x-name\"];\n            instruction[\"x-publicId\"] = node[\"x-publicId\"];\n            instruction[\"x-systemId\"] = node[\"x-systemId\"];\n        }\n        result = instruction;\n    }\n    else {\n        throw new Error(`Not implemented yet: ${node.type}`);\n    }\n    result.startIndex = node.startIndex;\n    result.endIndex = node.endIndex;\n    if (node.sourceCodeLocation != null) {\n        result.sourceCodeLocation = node.sourceCodeLocation;\n    }\n    return result;\n}\nfunction cloneChildren(childs) {\n    const children = childs.map((child) => cloneNode(child, true));\n    for (let i = 1; i < children.length; i++) {\n        children[i].prev = children[i - 1];\n        children[i - 1].next = children[i];\n    }\n    return children;\n}\n",null,null,null],"names":["HTML","HEAD","BODY","FIRST_TAG_REGEX","HEAD_TAG_REGEX","BODY_TAG_REGEX","parseFromDocument","html","tagName","Error","parseFromString","DOMParser","window","domParser_1","concat","document","implementation","htmlDocument_1","createHTMLDocument","element","documentElement","querySelector","innerHTML","parseFromTemplate","ElementType","template","createElement","content","childNodes","Root","Text","Directive","Comment","Script","Style","Tag","CDATA","Doctype","Node","constructor","this","parent","prev","next","startIndex","endIndex","parentNode","previousSibling","nextSibling","cloneNode","recursive","DataNode","data","super","nodeValue","arguments","type","nodeType","ProcessingInstruction","name","NodeWithChildren","children","firstChild","_a","lastChild","length","Document","Element","attribs","attributes","Object","keys","map","_b","value","namespace","prefix","isTag","node","elem","result","isText","isComment","cloneChildren","clone","forEach","child","isCDATA","isDocument","isDirective","instruction","sourceCodeLocation","childs","i","CASE_SENSITIVE_TAG_NAMES_MAP","reduce","accumulator","toLowerCase","formatAttributes","index","attributesLength","attribute","formatTagName","caseSensitiveTagName","getCaseSensitiveTagName","formatDOM","nodes","directive","current","domNodes","nodesLength","nodeName","push","substring","indexOf","unshift","DIRECTIVE_REGEX","TypeError","match","undefined","firstTagName","doc","test","removeChild","querySelectorAll","elements","domparser"],"mappings":"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","x_google_ignoreList":[1,2]}